#!/usr/bin/python
# coding: utf-8

import time, os , sys, select, signal
from datetime import datetime, timedelta

from www.maposmatic.models import MapRenderingJob
from www.settings import RENDERING_RESULT_PATH, LOG, RENDERING_RESULT_FORMATS, RENDERING_RESULT_MAX_SIZE_GB
import ocitysmap

def handler(signum, frame, pipe_write):
    f = os.fdopen(pipe_write, 'w')
    f.write("end")

def render_job_process(job):

    if job.administrative_city == "":
        bbox = ocitysmap.coords.BoundingBox(job.lat_upper_left,
                                            job.lon_upper_left,
                                            job.lat_bottom_right,
                                            job.lon_bottom_right)
        renderer = ocitysmap.OCitySMap(boundingbox=bbox)
    else:
        renderer = ocitysmap.OCitySMap(city_name=job.administrative_city)

    outfile_prefix = os.path.join(RENDERING_RESULT_PATH, job.files_prefix())

    _map = renderer.render_map_into_files(job.maptitle, outfile_prefix,
                                          RENDERING_RESULT_FORMATS, "zoom:16")

    renderer.render_index(job.maptitle, outfile_prefix,
                          RENDERING_RESULT_FORMATS, _map.width, _map.height)

    sys.exit(0)

def render_job(job):
    LOG.info("[job %d] starting rendering, title '%s'" % (job.id, job.maptitle))
    job.start_rendering()
    (pipe_read, pipe_write) = os.pipe()
    signal.signal(signal.SIGCHLD,
                  lambda signal, frame: handler(signal, frame, pipe_write))
    pid = os.fork()
    if pid == 0:
        # Son
        render_job_process(job)
    else:
        # Father
        try:
            (rlist, wlist, xlist) = select.select([pipe_read], [], [], 20*60)
            if rlist == [] and wlist == [] and xlist == []:
                os.kill(pid, signal.SIGTERM)
                time.sleep(2)
                os.kill(pid, signal.SIGKILL)
                resultmsg = "rendering took too long, killed"
                LOG.info("[job %d] %s" % (job.id, resultmsg))
                job.end_rendering(resultmsg)
                return
        finally:
            print "end of process %d" % pid
            (pid, status) = os.waitpid(pid, 0)
            resultmsg = "unknown error"
            if os.WIFEXITED(status):
                error_code = os.WEXITSTATUS(status)
                if error_code == 0:
                    resultmsg = "ok"
                else:
                    resultmsg = "rendering failed with %d" % error_code
            elif os.WIFSIGNALED(status):
                resultmsg = "rendering killed by signal %d" % os.WTERMSIG(status)
            LOG.info("[job %d] %s" % (job.id, resultmsg))
            job.end_rendering(resultmsg)
            return

# This function checks that the total size of the files in
# RENDERING_RESULT_PATH does not exceed 80% of
# RENDERING_RESULT_MAX_SIZE_GB. If it does, the function removes as
# many files as needed, oldest first
def cleanup_files():
    files = [ os.path.join(RENDERING_RESULT_PATH, f) for f in os.listdir(RENDERING_RESULT_PATH)]
    files = [(f, os.stat(f).st_ctime, os.stat(f).st_size) for f in files]
    size = reduce(lambda x, y: x + y[2], files, 0)
    threshold = 0.8 * RENDERING_RESULT_MAX_SIZE_GB * 1024 * 1024 * 1024
    if size < threshold:
        return
    files.sort(lambda x, y: cmp(x[1], y[1]))
    for f in files:
        os.remove(os.path.join(RENDERING_RESULT_PATH, f[0]))
        size -= f[2]
        LOG.debug("remove '%s', %f GB consumed over a %f GB threshold" % \
                            (f[0], (size / 1024 / 1024 / 1024), (threshold / 1024 / 1024 / 1024)))
        if size < threshold:
            break

if not os.path.isdir(RENDERING_RESULT_PATH):
    LOG.error("ERROR: please set RENDERING_RESULT_PATH ('%s') to an existing directory" % \
                        RENDERING_RESULT_PATH)
    sys.exit(1)

LOG.info("started")

# Reset the job that might have been left into the "rendering" state
# due to a daemon interruption back into the "waiting for rendering"
# state
jobs = MapRenderingJob.objects.filter(status=1)
for job in jobs:
    LOG.debug("reset job %d into waiting for rendering state" % job.id)
    job.status = 0
    job.save()

last_file_cleanup = None

while True:
    # Test each 20 seconds if we need to cleanup files
    if not last_file_cleanup or last_file_cleanup < (datetime.now() - timedelta(0, 20)):
        cleanup_files()
        last_file_cleanup = datetime.now()
    jobs = MapRenderingJob.objects.to_render()
    if not jobs:
        time.sleep(10)
    else:
        for job in jobs:
            render_job(job)
