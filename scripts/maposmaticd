#!/usr/bin/python
# coding: utf-8

# maposmatic, the web front-end of the MapOSMatic city map generation system
# Copyright (C) 2009  David Decotigny
# Copyright (C) 2009  Frédéric Lehobey
# Copyright (C) 2009  David Mentré
# Copyright (C) 2009  Maxime Petazzoni
# Copyright (C) 2009  Thomas Petazzoni
# Copyright (C) 2009  Gaël Utard

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import time, os , sys, select, signal, traceback, logging
from datetime import datetime, timedelta

from www.maposmatic.models import MapRenderingJob
from www.settings import RENDERING_RESULT_PATH, LOG, RENDERING_RESULT_FORMATS, RENDERING_RESULT_MAX_SIZE_GB, OCITYSMAP_CFG_PATH
from ocitysmap.coords import BoundingBox as OCMBoundingBox
from ocitysmap.street_index import OCitySMap 
import Image

def sigcld_handler(signum, frame, pipe_write):
    f = os.fdopen(pipe_write, 'w')
    f.write("end")

def render_job_process(job):

    if job.administrative_city == "":
        bbox = OCMBoundingBox(job.lat_upper_left, job.lon_upper_left,
                              job.lat_bottom_right, job.lon_bottom_right)
        renderer = OCitySMap(config_file=OCITYSMAP_CFG_PATH, boundingbox=bbox)
    else:
        renderer = OCitySMap(config_file=OCITYSMAP_CFG_PATH, city_name=job.administrative_city)

    outfile_prefix = os.path.join(RENDERING_RESULT_PATH, job.files_prefix())

    _map = renderer.render_map_into_files(job.maptitle, outfile_prefix,
                                          RENDERING_RESULT_FORMATS, "zoom:16")

    renderer.render_index(job.maptitle, outfile_prefix,
                          RENDERING_RESULT_FORMATS, _map.width, _map.height)

    if "png" in RENDERING_RESULT_FORMATS:
        mapimg = outfile_prefix + ".png"
        i = Image.open(mapimg)
        i.thumbnail((200,200), Image.ANTIALIAS)
        i.save(outfile_prefix + "_small.png")

    return 0

def render_job(job):
    LOG.info("[job %d] starting rendering, title '%s'" \
                 % (job.id, job.maptitle))
    job.start_rendering()
    (pipe_read, pipe_write) = os.pipe()
    pid = os.fork()
    if pid == 0:
        # Son
        tell_dad = os.fdopen(pipe_write, 'w')
        retval = 1
        try:
            retval = render_job_process(job)
        except KeyboardInterrupt:
            # Catch Ctrl-C  ~ gracefully
            tell_dad.write('Ctrl-C pressed. Bailing out.')
        except SystemExit, rv:
            # Pass-through any sys.exit() done from deep inside
            retval = rv
        except:
            # Tell the father what happened
            traceback.print_exc(file=tell_dad)
        finally:
            # And always return the proper exit code
            sys.exit(retval)

    else:
        # Father
        signal.signal(signal.SIGCHLD,
                      lambda signal, frame: sigcld_handler(signal, frame,
                                                           pipe_write))
        LOG.debug("start of process %d" % pid)
	# Don't close pipe_write here because the sigcld handler depends on it
        child_message = ""
        try:
            (rlist, wlist, xlist) = select.select([pipe_read], [], [], 20*60)
            if pipe_read in rlist:
                try:
                    child_endpoint = os.fdopen(pipe_read, 'r')
                    child_message  = child_endpoint.read()
                except Exception:
                    child_message = "(Could not retrieve error details)"
                    traceback.print_exc() # Dump this on stderr too
                else:
                    # Ignore exceptions when closing the pipe (child endpoint
                    # already closed, etc.)
                    try:
                        child_endpoint.close()
                    except:
                        pass
                return
            elif rlist == [] and wlist == [] and xlist == []:
                os.kill(pid, signal.SIGTERM)
                time.sleep(2)
                os.kill(pid, signal.SIGKILL)
                resultmsg = "rendering took too long, killed"
                LOG.info("[job %d] %s" % (job.id, resultmsg))
                job.end_rendering(resultmsg)
                return
        finally:
            print "end of process %d" % pid
            (pid, status) = os.waitpid(pid, 0)
            resultmsg = "unknown error"
            if os.WIFEXITED(status):
                error_code = os.WEXITSTATUS(status)
                if error_code == 0:
                    resultmsg = "ok"
                else:
                    resultmsg = "rendering failed with %d" % error_code
                    LOG.error("Failure in rendering child process:\n%s" \
                                  % child_message)
            elif os.WIFSIGNALED(status):
                resultmsg = "rendering killed by signal %d" \
                    % os.WTERMSIG(status)
            LOG.info("[job %d] %s" % (job.id, resultmsg))
            job.end_rendering(resultmsg)
            return

# This function checks that the total size of the files in
# RENDERING_RESULT_PATH does not exceed 80% of
# RENDERING_RESULT_MAX_SIZE_GB. If it does, the function removes as
# many files as needed, oldest first
def cleanup_files():
    files = [ os.path.join(RENDERING_RESULT_PATH, f) for f in os.listdir(RENDERING_RESULT_PATH)]
    files = [(f, os.stat(f).st_ctime, os.stat(f).st_size) for f in files]
    size = reduce(lambda x, y: x + y[2], files, 0)
    threshold = 0.8 * RENDERING_RESULT_MAX_SIZE_GB * 1024 * 1024 * 1024
    if size < threshold:
        return
    files.sort(lambda x, y: cmp(x[1], y[1]))
    for f in files:
        os.remove(os.path.join(RENDERING_RESULT_PATH, f[0]))
        size -= f[2]
        LOG.debug("remove '%s', %f GB consumed over a %f GB threshold" % \
                            (f[0], (size / 1024 / 1024 / 1024), (threshold / 1024 / 1024 / 1024)))
        if size < threshold:
            break

if not os.path.isdir(RENDERING_RESULT_PATH):
    LOG.error("ERROR: please set RENDERING_RESULT_PATH ('%s') to an existing directory" % \
                        RENDERING_RESULT_PATH)
    sys.exit(1)

logging.basicConfig()
LOG.info("started")

# Reset the job that might have been left into the "rendering" state
# due to a daemon interruption back into the "waiting for rendering"
# state
jobs = MapRenderingJob.objects.filter(status=1)
for job in jobs:
    LOG.debug("reset job %d into waiting for rendering state" % job.id)
    job.status = 0
    job.save()

last_file_cleanup = None


while True:
    # Test each 20 seconds if we need to cleanup files
    if not last_file_cleanup or last_file_cleanup < (datetime.now() - timedelta(0, 20)):
        cleanup_files()
        last_file_cleanup = datetime.now()
    jobs = MapRenderingJob.objects.to_render()
    if not jobs:
        time.sleep(10)
    else:
        for job in jobs:
            render_job(job)
